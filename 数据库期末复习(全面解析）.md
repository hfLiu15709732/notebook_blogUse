# 数据库期末复习(全面解析）



![](https://blog-use-1316646528.cos.ap-nanjing.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93/databaseBaner.png)

## 第一部分：基本理论

### 1.1 四个基本概念

1. **数据：**描述事物的符号记录
2. **数据库：**概括地讲，数据库数据具有永久存储、有组织和可共享的三个基本特点。 
3. **数据库管理系统：**是位于⽤户和操作系统之间的⼀层数据管理软件
4. **数据库系统：**是由数据库、数据库管理系统（及其应⽤开发⼯具）、应⽤程序和数据库管理员（DBA）组成的存储、管理、处理和维护数据的系统。



### 1.2 主要功能

1. 数据**定义**功能 
2. 数据组织、**存储**和管理  
3. 数据操纵功能
4. 数据库的**事务管理和运⾏管理**
5. 数据库的**建⽴和维护**功能
6. 其他功能（**通信**功能，**数据转换**功能，**互访和互操作**功能等）



### 1.3 主要特点：

1. 实现整体数据的**结构化**
2. 数据的**共享性⾼、冗余度低且易扩充：**数据共享可以⼤⼤减少数据冗余，节约存储空间
3.  数据独⽴性⾼：
4. **物理独⽴性**：是指⽤户的应⽤程序与数据库中数据的物理存储是相互独⽴的。
5. **逻辑独⽴性：**是指⽤户的应⽤程序与数据库的逻辑结构是相互独⽴的。
6. 数据由数据库管理系统统⼀管理和控制











## 第二部分：关系型数据库



## 第三部分：SQL语言（上）

### 3.1基本概念

**基本理论：**

> **SQL**是**Structured Query Language**的缩写，意思是结构化查询语⾔，是⼀种在数据库管理系统中查询或对数据库⾥⾯的数据进⾏更改的语⾔

**SQL语言分类:**

1. 数据定义语⾔DDL（Data Ddefinition Language）

   SQL数据定义语⾔主要⽤来定义逻辑结构，包括定义基表，视图和索引。删除表 定义表 修改表

2. 数据查询语⾔DQL（Data Query Language）

   SQL的数据查询语⾔主要⽤来对数据库中的各种数据对象进⾏查询。

3.  数据操纵语⾔DML（Data Manipulation Language）

   SQL的数据操纵语⾔，⽤于改变数据库中的数据，包括插⼊，删除，修改

4. 数据控制功能DCL（Data Control Language）

   SQL的数据控制语⾔，对表和视图的授权，完整性规则的描述以及事务开始和结束等控制语句。

   



### 3.2特点：

- **一体化**。SQL语言风格统一，可以完成数据库活动中的全部工作，包括创建数据库、定义模式、更改和查询数据以及安全控制和维护数据库等。
- **高度非过程化**。在使用SQL语句访问数据库时，用户没有必要告诉计算机如何一步步完成任务，只需要用SQL语言描述要做什么就行了，数据库管理系统会自动完成全部工作。
- **面向集合的操作方式**。SQL语言采用集合操作方式，不仅查询结果是记录的集合，而且插入、删除和更新操作也是记录的集合。
- **提供多种方式使用**。SQL既是自含式语言，又是嵌入式语言。自含式语言可以独立地联机交互，即用户可以直接以命令的方式交互使用。嵌入式语言是指SQL可以嵌入到向Java、C#等高级程序设计语言中使用。
- **语言简洁**。SQL语法简单，易学易用



### 3.3数据类型：

以在 MySQL 中的数据类型为例，有三种主要的类型：**文本**、**数字**和**日期/时间**类型。

**Text 类型：**

| 数据类型               | 描述                                                         |
| :--------------------- | :----------------------------------------------------------- |
| CHAR(*size*)           | 保存固定长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的长度。最多 255 个字符。 |
| VARCHAR(*size*)        | 保存可变长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的最大长度。最多 255 个字符。注释：如果值的长度大于 255，则被转换为 TEXT 类型。 |
| TINYTEXT               | 存放最大长度为 255 个字符的字符串。                          |
| TEXT                   | 存放最大长度为 65,535 个字符的字符串。                       |
| BLOB                   | 用于 BLOBs (Binary Large OBjects)。存放最多 65,535 字节的数据。 |
| MEDIUMTEXT             | 存放最大长度为 16,777,215 个字符的字符串。                   |
| MEDIUMBLOB             | 用于 BLOBs (Binary Large OBjects)。存放最多 16,777,215 字节的数据。 |
| LONGTEXT               | 存放最大长度为 4,294,967,295 个字符的字符串。                |
| LONGBLOB               | 用于 BLOBs (Binary Large OBjects)。存放最多 4,294,967,295 字节的数据。 |
| ENUM(*x*,*y*,*z*,etc.) | 允许你输入可能值的列表。可以在 ENUM 列表中列出最大 65535 个值。如果列表中不存在插入的值，则插入空值。注释：这些值是按照你输入的顺序存储的。可以按照此格式输入可能的值：ENUM('X','Y','Z') |
| SET                    | 与 ENUM 类似，SET 最多只能包含 64 个列表项，不过 SET 可存储一个以上的值。 |



**Number 类型：**

| 数据类型            | 描述                                                         |
| :------------------ | :----------------------------------------------------------- |
| TINYINT(*size*)     | -128 到 127 常规。0 到 255 无符号*。在括号中规定最大位数。   |
| SMALLINT(*size*)    | -32768 到 32767 常规。0 到 65535 无符号*。在括号中规定最大位数。 |
| MEDIUMINT(*size*)   | -8388608 到 8388607 普通。0 to 16777215 无符号*。在括号中规定最大位数。 |
| INT(*size*)         | -2147483648 到 2147483647 常规。0 到 4294967295 无符号*。在括号中规定最大位数。 |
| BIGINT(*size*)      | -9223372036854775808 到 9223372036854775807 常规。0 到 18446744073709551615 无符号*。在括号中规定最大位数。 |
| FLOAT(*size*,*d*)   | 带有浮动小数点的小数字。在括号中规定最大位数。在 d 参数中规定小数点右侧的最大位数。 |
| DOUBLE(*size*,*d*)  | 带有浮动小数点的大数字。在括号中规定最大位数。在 d 参数中规定小数点右侧的最大位数。 |
| DECIMAL(*size*,*d*) | 作为字符串存储的 DOUBLE 类型，允许固定的小数点。             |



> **这些整数类型拥有额外的选项 UNSIGNED。通常，整数可以是负数或正数。如果添加 UNSIGNED 属性，那么范围将从 0 开始，而不是某个负数。**



**Date 类型：**

| 数据类型    | 描述                                                         |
| :---------- | :----------------------------------------------------------- |
| DATE()      | 日期。格式：YYYY-MM-DD注释：支持的范围是从 '1000-01-01' 到 '9999-12-31' |
| DATETIME()  | *日期和时间的组合。格式：YYYY-MM-DD HH:MM:SS注释：支持的范围是从 '1000-01-01 00:00:00' 到 '9999-12-31 23:59:59' |
| TIMESTAMP() | *时间戳。TIMESTAMP 值使用 Unix 纪元('1970-01-01 00:00:00' UTC) 至今的描述来存储。格式：YYYY-MM-DD HH:MM:SS注释：支持的范围是从 '1970-01-01 00:00:01' UTC 到 '2038-01-09 03:14:07' UTC |
| TIME()      | 时间。格式：HH:MM:SS注释：支持的范围是从 '-838:59:59' 到 '838:59:59' |
| YEAR()      | 2 位或 4 位格式的年。注释：4 位格式所允许的值：1901 到 2155。2 位格式所允许的值：70 到 69，表示从 1970 到 2069。 |



> 即便 DATETIME 和 TIMESTAMP 返回相同的格式，它们的工作方式很不同。在 INSERT 或 UPDATE 查询中，TIMESTAMP 自动把自身设置为当前的日期和时间。TIMESTAMP 也接受不同的格式，
>
> 比如 **YYYYMMDDHHMMSS**、
>
> **YYMMDDHHMMSS**、
>
> **YYYYMMDD** 或 **YYMMDD**。





### 3.4 模式相关操作

```sql
create schema "hfx" authorization dbuser;
-- 模式定义


-- 模式定义加视图


drop schema "hfx" CASCADE;
-- 模式删除

-- 注意：在删除时，必须接上CASCADE 或者 RESTRICT

-- 关系：
-- CASCADE是(级联)  删除模式的同时也把该模式的所有数据库对象删除. 
-- RESTRICT(限制)    如果该模式下有下属对象,⽐如表视图  就拒绝这个删除语句的执⾏ 

```



### 3.5  基本表相关操作

```sql
CREATE TABLE table_name (column_name column_type); -- 通用语法


CREATE TABLE IF NOT EXISTS `hfX_tab`(
   `id` INT UNSIGNED AUTO_INCREMENT primary key, -- 主键且是自增属性
   `title` VARCHAR(100) NOT NULL, -- 非空属性
   `author` VARCHAR(40) NOT NULL,
   `time` DATE,
   PRIMARY KEY ( `runoob_id` )
)ENGINE=InnoDB DEFAULT CHARSET=utf8; -- ENGINE 设置存储引擎，CHARSET 设置编码。
-- 1.创建基本表


drop table hfX_tab CASCADE;
-- 2.删除基本表

-- 注意：
-- 使用CASCADE 是如果表有外键,视图 触发器的话,也会强⾏删除
-- RESTRICT会拒绝删除


-- 3.修改表（放下面了）




ALTER TABLE <表名> ADD COLUMN <列名> <类型>


-- 3.1 (添加属性）




ALTER TABLE <表名> CHANGE COLUMN <旧列名> <新列名> <新列类型>
-- 或者
ALTER COLUMN <列名> { SET DEFAULT <默认值> | DROP DEFAULT }
-- 或者
MODIFY COLUMN <列名> <类型>


-- 3.2 (修改属性） 


```

 

### 3.6  索引相关操作

```sql
ALTER TABLE <表名> DROP COLUMN <列名>
-- 3.3 (删除属性）



create index <索引名> on <表名> (列名) -- 一般索引
create UNIQUE index <索引名> on <表名> (列名) -- 唯一索引
create CLUSTER index <索引名> on <表名> (列名) -- 聚簇索引
-- 3.4 (索引的建立）（建立分为 一般 聚簇索引  唯一索引）


ALTER INDEX <旧索引名> RENAME TO <新索引名>
-- 3.5 (索引的修改）


DROP INDEX <索引名>
-- 3.6 (索引的删除）

```



### 3.7  相关注意点：

#### 主键与唯一索引的关系

1. 主键一定是唯一性索引，唯一性索引并不一定就是主键。 

2.  一个表中可以有多个唯一性索引，但只能有一个主键。

3. 主键列不允许空值，而唯一性索引列允许空值。

4. 索引可以提高查询的速度

5. 当没有设定**主键**时，**非空唯一索引**自动称为**主键**。

6. 表中的数据在此列必须是不相同（不管是主键还是唯一索引，都是这样）

   



#### 一般索引与唯一索引与聚簇索引的关系

> **首先：索引主要用于提高数据库的查询性能；**



**一般索引:**

- 简单的索引,允许索引列的值重复。

- 通过一般索引可以查询指定的值,也可以查询范围内的值。

- 一般索引的数据列允许有NULL值。

  

**唯一索引:**

- 索引列的值必须唯一,不允许重复。
- 可以通过唯一索引快速查询到指定的值,但无法进行范围查询。
- 唯一索引的数据列允许有NULL值,但NULL值只能有一个。



**聚簇索引:**

-  将表中行数据的物理顺序与索引值的逻辑顺序相对应。
- 聚簇索引的表数据行会以索引值的顺序存储,所以通过聚簇索引查询可以直接定位到数据。
- 每个表只能有一个聚簇索引。
- 聚簇索引不允许有NULL值。



**所以，关系总结为：**

1. 唯一索引是在一般索引的基础上加了唯一性约束。
2. 聚簇索引会对表数据进行物理重组,其他索引则只保存索引值和行指针的对应关系。
3. 相比一般索引和唯一索引,聚簇索引可以更快地查询数据。
4. 一个表只能有一个聚簇索引,但可以有多个一般索引或唯一索引。





## 第四部分：SQL语言（中）



### 4.1  一般查询部分



```sql
SELECT * FROM "hfX_tab";
-- 查询所有


SELECT id as "编号" , titlt as "名称" from "hfX_tab" as "学生表";
-- 查询部分列


SELECT distinct titlt as "名称" from "hfX_tab";
--  查询去重


```





### 4.2 代运算符的查询部分



> **所涉及的表**

| 符号            | 描述                       | 备注                                                         |
| :-------------- | :------------------------- | :----------------------------------------------------------- |
| =               | 等于                       |                                                              |
| <>, !=          | 不等于                     |                                                              |
| >               | 大于                       |                                                              |
| <               | 小于                       |                                                              |
| <=              | 小于等于                   |                                                              |
| >=              | 大于等于                   |                                                              |
| BETWEEN         | 在两值之间                 | >=min&&<=max                                                 |
| NOT BETWEEN     | 不在两值之间               |                                                              |
| IN              | 在集合中                   |                                                              |
| NOT IN          | 不在集合中                 |                                                              |
| <=>             | 严格比较两个NULL值是否相等 | 两个操作码均为NULL时，其所得值为1；而当一个操作码为NULL时，其所得值为0 |
| LIKE            | 模糊匹配                   |                                                              |
| REGEXP 或 RLIKE | 正则式匹配                 |                                                              |
| IS NULL         | 为空                       |                                                              |
| IS NOT NULL     | 不为空                     |                                                              |





```sql

SELECT * FROM "hfX_tab" where title="h1";

-- 约束字符WHERE

SELECT * FROM "hfX_tab" where score < = 85;

-- 相关比较符

SELECT * FROM "hfX_tab" where age BETWEEN 80 AND 100;
SELECT * FROM "hfX_tab" where age in（80,100）;

-- 范围运算符 between and 和in

select * from table1 where name like '%刘浩%'   -- 查询name字段中包含有  刘浩  的。
select * from table1 where name like '刘* '     -- 查询name字段中以  刘  开头。
select * from table1 where name like '_刘'      -- 


-- 模糊匹配 like   百分号与下划线关系



SELECT * FROM "hfX_tab" where title is NULL;
-- 判断空字符 null


SELECT * FROM "hfX_tab" where title="h1" AND id="22";
SELECT * FROM "hfX_tab" where title="h1" or id="22";

-- and和or(就是字面意思理解就可以了)


```





### 4.3 聚集函数与分组查询



> **具体的聚集函数**

| 聚集函数 | 功能               | 格式                                  | 数据类型                       |
| -------- | ------------------ | ------------------------------------- | ------------------------------ |
| count    | 求符合条件的记录数 | count(列名) 或者 count(DISTINCT 列名) |                                |
| MAX      | 求某一列的最大值   | MAX(列名)                             | 列的类型可以比较大小           |
| MIN      | 求某一列的最小值   | MIN(列名)                             | 列的类型可以比较大小           |
| AVG      | 求某一列的平均值   | AVG(列名)                             | 列的类型只能是数值型或者货币型 |
| SUM      | 求某一列的总和     | SUM(列名)                             | 列的类型只能是数值型或者货币型 |



```sql
select count（*）FROM "hfX_tab"; 
-- count（*） 不包含重复的


select count（title）FROM "hfX_tab" WHERE age = "22"; 
-- count（列名）包含重复的 但不包含空值
-- 想要不重复的 加distinct就行 


select sum（salary）FROM "hfX_tab"; 
-- sum（列名）


select AVG（salary）FROM "hfX_tab"; 
-- avg（列名）


select MAX（salary）FROM "hfX_tab"; 
-- max（列名）


select MIN（salary）FROM "hfX_tab"; 
-- min（列名）




SELECT * from "hfX_tab" WHERE kind="student" GROUP BY grade 
-- 分组 group by
-- 例子的意思是 查询属于学生类型的人所有信息 并按找年级分组



SELECT * from "hfX_tab" WHERE kind="student" GROUP BY grade HAVING COUNT（*）>100;
-- 对每组的组相同数据进行分组  用having
-- 例子的意思是 找出属于学生类型的人所有信息 并按找年级分组，只查询其中人数大于100的年级；
```











### 4.4 连接查询部分



```sql

select userTab，goodsTab where userTab.id=goodsTab.id 
-- (一般项目不会起名为id   ；对应是user表的外键就可以  也可能是userID/......)

-- 两张基本表进行基础连接 （求两张表的笛卡尔积）




select userTab as "ec1"，userTab as "ec2" where ec.id=ec2.id
-- 自身连接 




select * from userTab  left join goodsTab ON userTab.id=goodsTab.id
-- 左外连接（外连接每个数据库语言不通，这里演示的是mysql的连接）
-- 会将左表中的全部数据拿出来 按照匹配条件和右表中数据做对应，左表中没有匹配上的数据会被置空（null）




-- 右外连接就是将left改成right 
-- 具体不解释 将上面的外面的反过来就行


-- 外连接比较抽象，这里没有实例  
-- 看这里：https://blog.csdn.net/wulimingde/article/details/109134307







-- 多表查询部分（两个表以上的连查）





select * from goodsTab where userID in（select  id from userTab where age<18）
-- 嵌套查询
-- 例子的意思是检索网站中年龄小于18岁的用户所购买的商品的全部信息


-- 嵌套查询简单来说就是：底层的检索结果是上层检索的准备








select * from emp where scal > any (select scal from emp where deptno=10 )and deptno <> 10;
-- 查询工资大于部门编号是10的任意的一个员工工资即可的其他部门的员工信息


select * from  emp where scal > all  (select scal from emp where deptno =30) and deptno <>30;
-- 查询工资大于部门编号是30的所有的员工工资的员工信息
-- 所以 大约等于下面这个
select  * from emp where scal >  (select max(scal) from emp where deptno =30) and deptno <> 30;



-- 带 ANY ALL的子查询 就不用写in了
-- 意思是：
--       假设子查询 查出来了 13和16和12和11四条数据
--       那么>ANY()就是大于11的即可
--       那么>ALL()就是大于16的才可以








SELECT s.Sname FROM student s
WHERE NOT EXISTS  
(SELECT * FROM sc, course c WHERE sc.sno = s.sno AND sc.cno = c.cno AND c.cname = '数字电路')
-- 查询没有选修课程   数字电路   的同学




SELECT Sname  
FROM Student   
WHERE NOT EXISTS  
(SELECT * FROM Course WHERE NOT EXISTS  
     (SELECT * FROM SC WHERE Sno=Student.Sno AND Cno=Course.Cno)  
);  
-- 查询选修了全部课程的学生姓名




-- 上面是带exists的子查询（经典例子，理解上面两个这个应该就OK了）
-- 例子的意思是：
-- NOT EXISTS 理解为意思取反即可  where NOT EXISTS

```





### 4.5 集合查询



```sql

(select Mname from mangerTab)
union
(select Tname from teacherTab)

-- 求并集   返回两个子结果集的并集
-- 两个select中间加上UNION即可





(select Mname from mangerTab)
INTERSECT
(select Tname from teacherTab)

-- 求交集    返回两个结果集的交集（返回相同记录）
-- 两个select中间加上INTERSECT即可


(select Mname from mangerTab)
EXCEPT
(select Tname from teacherTab)
-- 求差集
-- 两个select中间加上EXCEPT即可




-- 意思很好理解，就不解释了，想看例子的可以看这个
-- 链接：https://blog.csdn.net/sinat_32832727/article/details/54177602
```





## 第四部分：SQL语言（下）

### 4.1 元组操作部分：

```sql

-- 增加元组 （注意！ 注意！ 如果数据库中的id或其他列具有自增属性，插入时，不能手动插入改数据，否则直接报错）

INSERT INTO table_name (column1,column2,column3,所有列名)VALUES (value1,value2,value3，所有列值);
-- 指定 所有字段

INSERT INTO userTab (id,name,age) VALUES (17,"张三",22);
-- 指定部分字段

INSERT INTO userTab VALUES (18,"李四",19);
-- 不指定，默认全部字段



insert into bookTab values 
						('三国演义', '罗贯中', 88, '古典小说'),
                        ('水浒传', '施耐庵', 120, '古典小说');
                        ('三国演义2', '罗贯中', 88, '古典小说'),
                        ('水浒传2', '施耐庵', 120, '古典小说');
                        ('三国演义3', '罗贯中', 88, '古典小说'),
                        ('水浒传3', '施耐庵', 120, '古典小说');
                        
-- 批量添加数据




update 表名 set 列名1=新数据1,列名2=新数据2列名3=新数据3 where 查询条件

update userTab set name="王五",age=30,password="lxc123" where id=38; --例子
-- 修改元组


delete from 表名 where 查询条件;

delete from book where id = 37; -- 例子
-- 删除元组
```



### 4.2 视图操作部分：



#### 4.2.1 视图概念与理论：

- 视图(VIEW)也被称作虚表，即虚拟的表，是⼀组数据的逻辑表示,其本质是对应于⼀条SELECT
  结果集被赋予⼀个名字，即视图名字
- 视图本身并不包含任何数据，它只包含映射到基表的⼀个查询语句，当基表数据发⽣变化，视图随即变化
- ⽬的: ⽅便,简化数据操作
- 当我们业务需求要查出多张表的数据,这时我们可能会关联多张表查询处理，如果这个联合查询的sq语句很复杂，会严重影响了查询效率.这个时候我们就可以创建视图,查询时候只需要查询相应的试图就可以！



#### 4.2.2 视图操作代码：

```sql
CREATE VIEW userView("姓名"，"年龄"，"时间") AS SELECT (name，age，time) from userTab 
where age>18 WITH CHECK OPTION -- 例子

-- 创建视图
-- 当使用了 [WITH CHECK OPTION] 约束后，视图会对基本表增添的数据进行最初的约束检验，符合之后才会加到视图中


DROP VIEW userView CASCADE;
-- 删除视图 有cascade
-- CASCADE与之前一样，是级联的意思，即当他存在着子视图的时候，会一同删除了。
-- 如果不写，且存在子视图，会报错（拒绝删除）



select * from userView where age<60;
-- 查询视图
-- 使用视图和使用表完全一样，只需要把视图当成一张表就OK了。视图是一张虚拟表。



-- （视图只是映射，需要反映到基本表，要么直接修改基本表，要么两个都修改）
-- 修改视图


-- 对于一般视图，要注意：

-- 1. 视图修改，会影响基本表数据；
-- 2. 基本表修改，也会影响到视图的数据
-- 3. 因为本身就只有一份数据，视图只是映射的信息




```



#### 4.2.3 一般视图与物化视图的区别

**一般视图：**

- 虚拟表,没有数据的实际存储,只保存 SQL 语句
- 当访问视图时,会执行其 SQL 语句并返回结果。
- 一般视图的数据是动态的,取决于其 SQL 语句查询的基表数据。
- 创建语法:`CREATE VIEW view_name AS select_statement`



**物化视图：**

- 实际上是一个表,存储了查询结果的数据
- 数据与基表分离,数据变化时需要定期刷新与基表同步
- 相比一般视图,查询性能更高,因为直接从已存储的数据中获取结果。
- 创建语法:`CREATE MATERIALIZED VIEW view_name AS select_statement`



**相关小例子：**

```sql

-- 一般视图
CREATE VIEW prod_view AS 
SELECT * FROM products;


-- 物化视图
CREATE MATERIALIZED VIEW prod_mview AS 
SELECT * FROM prod_view;

-- 刷新物化视图
REFRESH MATERIALIZED VIEW prod_mview; 




-- 简析：
-- 我们定义了一个基于 products 表的一般视图 prod_view
-- 然后创建物化视图 prod_mview ,内容来自 prod_view 的查询结果
-- 通过 REFRESH 语句可以定期刷新 prod_mview,保证其数据与基表 products 同步
-- 这样既可以通过 prod_view 动态地链接基表,也可以直接查询 prod_mview 获得更高的性能

```



**两者关系：**

- 物化视图的内容来自其选择语句查询的结果,而选择语句可以定义在一般视图上
- 所以可以将一般视图的内容定期刷新到物化视图中,物化视图实时保持与基表的数据同步
- 这种结合可以同时获得一般视图的动态联系和物化视图的查询性能









## 第五部分：数据库安全控制

### 5.1 数据库安全概念：

```sql
-- 第一类：用户身份鉴别

-- 静态口令鉴别
-- 动态口令鉴别
-- ⽣物特征鉴别
-- 智能卡鉴别




-- 第二类：存取控制
-- 就是我们⽤户可以⾃定义和分配其他⽤户的操作
-- 下面有具体阐述

```





### 5.2 自主存取控制的代码部分：



#### 5.2.1 基本权限控制：

```sql

-- 首先，要清楚数据库中的权限控制：
-- 数据库的权限控制主要通过用户、权限和用户组实现。主要的权限有:
--  SELECT:允许读取数据
--  INSERT:允许插入数据
--  UPDATE:允许更新数据
--  DELETE:允许删除数据
--  CREATE:允许创建数据库和表
--  DROP:允许删除数据库和表
--  GRANT:允许授予权限
--  REVOKE:允许撤销权限
--  ALTER:允许修改表结构
--  INDEX:允许创建和删除索引
--  etc.




-- 涉及的相关操作：

-- 创建用户：
CREATE USER '用户名' IDENTIFIED BY '密码';



-- 删除用户：
DROP USER '用户名';




-- 修改用户密码：
SET PASSWORD FOR '用户名' = PASSWORD('新密码');




-- 创建角色：
create role <⻆⾊名>
create role teacherRole;







-- 授予权利的方式：

GRANT 权限 ON 数据库名.表名 TO '用户名' With  grant  option;
GRANT select ON database1.userTab TO 'xiaoming' With  grant  option;
GRANT select ON database1.userTab(userName) TO 'xiaoming' With  grant  option;
-- 注意：With  grant  option⼦句，代表普通⽤户获权后,可把⾃⼰的权限授予其他⽤户



-- 角色权限授予：
grant select on  userTab to "teacherRole","stuRole"    




-- 挥手权限：
REVOKE <权限> ON <数据对象>  FROM <⽤户名>  cascade

REVOKE select ON userTab(userName)  FROM "xiaoming"  cascade;



```



#### 5.2.2 视图机制：

```sql
-- 实现目的：为不同的⽤户定义不同的视图，把不需要的数据给隐藏起来，这样⽤户就不会进⾏误操作


-- 例子A：
 create view userTab_Stu as
   select * from students where age='18'
   
 grant select on userTab_Stu to "学生A"；
 
 
 
-- 例子B：
grant all privileges on userTab_Stu to "班长";

```



#### 5.2.3 审计与数据加密：

```sql

-- 审计：
-- 概念：把对数据库的所有操作都记录到审计⽇志中，然后就可以通过⽇志审查这个⾥⾯是否有⼀些⾮法

-- 1.例子:对修改用户表的数据进行审计
-- audit  update on userTab;

-- 2.例子：取消对用户表的所有审计；
-- noaudit update on userTab;






-- 数据加密: 通过⼀些加密算法，把明⽂变成密⽂，这样别⼈就⽆法查看

-- 例如基于MD5加密方式：先对数据进行MD5的加密，在将秘文中的数据添加一些特有标记位；即可达到机密的效果
```



## 第六部分：数据库完整性

### 6.1 完整性概述：

#### 6.1.1 正确性：

**符合现实世界的描述**

#### 6.1.2 相容性：

**同⼀对象在不同表⾥⾯是符合逻辑的  ⽐如我的地址,年龄   在两个表⾥⾯都应⼀致**

#### 6.1.3 维护完整性：

1. 提供定义完整性约束条件的机制
2. 提供完整性检查的⽅法
3. 进⾏违约处理



### 6.2 三大完整性：

#### 6.2.1  实体完整性

```sql
Create table t1(
​	  id int primary key auto_increment,-- 在表级定义实体完整性
​	  name varchar(100)，
    	age INT
);

create table SC(
    Sno char(9) not null,
    Cno char(4) not null,
    Grade int,
    primary key (Sno, Cno),  -- 在表级定义实体完整性
    );

-- 实体完整性
-- 主码唯一且非空


-- 上面两个例子即为在创建表时设立主键的形式
```



#### 6.2.2  参照完整性



```sql
create table SC(
    Sno char(9) not null,
    Cno char(4) not null,
    Grade int,
    primary key (Sno, Cno),  /*在表级定义实体完整性*/
    foreign key (Sno) references Student(SNO),  /*在表级定义参照完整性*/
    foreign key (Cno) references Course(Cno)    /*在表级定义参照完整性*/
    );


-- 参照完整性
-- 对于外码 要么没有，要么只有一个
-- 也就是外键
```



#### 6.2.3  用户自定义完整性



```sql
-- 1.定义NULL/NOT NULL约束
CREATE TABLE nation2(/*国家表*/
  nationkey INTEGER PRIMARY KEY,           /*国家编号*/
  name CHAR(25)NOT NULL,                   /*国家名称*/
  regionkey INTEGER REFERENCES region(regionkey),/*地区编号*/
  comment VARCHAR(152)NULL                 /*备注*/
);



-- 2.定义属性的缺省值
-- 定义零件基本表的制造厂的缺省值为，表示其他厂商
CREATE TABLE part2(/*零件基本表*/
  partkey INTEGER PRIMARY KEY,             /*零件编号*/
  name VARCHAR(100),                       /*零件名称*/
  mfgr CHAR(50)DEFAULT '0',                /*制造厂*/
  brand VARCHAR(50),                       /*品牌*/
  type VARCHAR(25),                        /*零件类型*/
  size INTEGER,                            /*尺寸*/
  container CHAR(10),                      /*包装*/
  retailprice REAL,                        /*零售价格*/
  comment VARCHAR (23)                     /*备注*/
);



-- 3.定义属性UNIQUE约束
-- 定义地区表的地区名称必须唯一的约束
CREATE TABLE region2(/*地区表*/
  regionkey INTEGER PRIMARY KEY,           /*地区编号*/
  name CHAR(25)UNIQUE,                     /*地区名称*/
  comment CHAR(152)                        /*备注*/
);



-- 4.使用CHECK
-- 使用CHECK定义订单表中某些属性应该满足的约束
CREATE TABLE orders2(/*订单表*/
   orderkey INTEGER PRIMARY KEY,/*订单编号*/
   custkey INTEGER,/*顾客编号*/
   
   /*订单状态有中，0表示尚未处理，1表示已经处理*/
   orderstatus CHAR(1)CHECK(orderstatus IN('0','1')),/*订单状态*/
   totalprice REAL,/*订单总金额*/
   orderdate DATE,/*订单日期*/
   
   /*订单优先级有三等，0表示最高，1次之，2表示最低*/
   orderpriority CHAR(15)CHECK (orderpriority IN('0','1','2')),/*订单优先级别*/
   clerk CHAR(15),/*记账员*/
   shippriority INTEGER ,/*运输优先级别*/
   comment VARCHAR(79),/*备注*/
  );


-- 用户自定义完整性

-- 3种主要形式：

-- 1. 非空   not null

-- 2. 定义属性的缺省值 default

-- 3. 列值唯一  unique

-- 4. 满足一个表达式，check来写



```





### 6.3 断言：

通过声明性断言(***declarative assertions***)来制定更具一般性的约束。

每个断言都被赋予一个名字，`<CHECK子句>`中的约束条件与`WHERE`子句的条件表达式类似

```sql
CREATE ASSERTION <断言句> <CHECK 子句>


CREATE ASSERTION duanyan1 
	CHECK(60>=(SELECT COUNT(*) 
		FROM Course,SC WHERE SC.Cno=Course.Cno AND Course.Cname=’数据库’)
	);
	
	-- 限制数据库课程选修人数不超过60人


-- 创建断言


DROP ASSERTION <断言名字>
-- 删除断言
```





### 6.4 触发器：

#### 6.4.1 基础概念

- 触发器是与表有关的数据库对象，在满足定义条件时触发，并执行触发器中定义的语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性。
- 遵循   **事件-条件->动作**  的规则
- 意思是：执行时触发了预定的规则，则执行相应的动作，否则不做



#### 6.4.2 触发器分类

| 类型   | 解释                             |
| ------ | -------------------------------- |
| before | *表示在数据库动作之前触发器执行* |
| after  | *表示在数据库动作之后出发器执行* |



| 类型   | 解释                     |
| ------ | ------------------------ |
| insert | 数据库插入会触发此触发器 |
| update | 数据库修改会触发此触发器 |
| delete | 数据库删除会触发此触发器 |



| 类型         | 解释                                     |
| ------------ | ---------------------------------------- |
| for each row | 对表的每一行触发器执行一次（行级触发器） |
| 默认         | 则只对一整个语句执行一次（语句级触发器） |

创建触发器的完整语法规则

```sql
CREATE TRIGGER trigger_name
trigger_time
trigger_event ON tbl_name
FOR EACH ROW
trigger_stmt

-- trigger_name：标识触发器名称，用户自行指定
-- trigger_time：标识触发时机，取值为 BEFORE 或 AFTER
-- trigger_event：标识触发事件，取值为 INSERT、UPDATE 或 DELETE
-- tbl_name：标识建立触发器的表名，即在哪张表上建立触发器
-- trigger_stmt：触发器程序体，可以是一句SQL语句，或者用 BEGIN 和 END 包含的多条语句




CREATE TRIGGER test_user
AFTER INSERT ON "userTab"
FOR EACH ROW
BEGIN
	INSERT INTO bysj_dt VALUES (new.id,new.et_name);
END

-- 常见触发器案例（行级 插入 后执行触发器）



DROP TRIGGER test_user
-- 删除触发器



show triggers
-- 查看所有触发器

```





## 第七部分：关系型数据库理论





### 7.1 候选码与最小候选码

#### 7.1.1 概念：

- **候选码(Candidate Key):**能够唯一标识表中的每条记录的数据集合。一个表可以有多个候选码
- **最小候选码(Minimal Candidate Key):**一个表中不包含冗余的候选码。它是所有候选码中包含数据量最少的一个。

**样例：**

```sql

-- 例如,在学生表中,学号、姓名加出生日期都可以唯一标识一条学生记录,所以它们都是候选码。
-- 例如,在学生表中,学号长度最小,只需要一个属性即可唯一标识一条记录,所以学号是最小候选码。而姓名加出生日期包含两个属性,相对来说数据量更大一些。


-- 所以：一个表的主键必须是最小候选码,但最小候选码不一定是主键。主键是表中记录的唯一标识,是实现其他表与之建立关系的依据,所以要求不可为空和不可重复。

```





#### 7.1.2 求候选码：

```sql

-- 第一步，根据规则筛选
-- 规则是：
-- 1.只出现在左边的⼀定是候选码   
-- 2.只出现在右边的⼀定不是候选码
-- 3.左右都出现的不⼀定
-- 4.左右都不出现的⼀定是候选码



-- 第二部：
-- 再求确定的候选码的闭包,如果可以推出全部,那么当前确定的就是候选码
```

![](https://blog-use-1316646528.cos.ap-nanjing.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93/dbUse1.jpg)



#### 7.1.3 超码与相关概念：

```sql
-- 超码：能表示出所有属性的集合, ⽐如 (BDA),(BDC),(BDE) BDCA  BDEA ABCDE
-- 通过上面可以看出候选码肯定是，再在候选码基础上加数也一定是（因为更能推出全部关系）


-- 主码: 从候选码⾥⾯任意跳出⼀个 作为主码
-- 主属性: 包含在所有候选码的属性  比如ABCDE
-- 非主属性: 不包含在候选码中的属性 ,上题为G
-- 全码: 所有的属性都是主码
```



### 7.2 三大范式与BCNF

#### 7.2.1 范式的定义分类：

```sql

-- 第一范式  1NF
-- 定义：所有字段值都是不可分解的原⼦值
-- 人话：上面已经是人话了




-- 第二范式  2NF
-- 定义：包含⾮主属性对码的部分函数依赖
-- 人话：⼀个表中只能保存⼀种数据，不可以把多种数据保存在同⼀张数据库表中
-- 例如：商品编号与订单编号就是两类数据，应该分开两个表进行存储




-- 第三范式  3NF
-- 定义：不包含⾮主属性对码的传递函数依赖
-- 人话：数据表中的每⼀列数据都和主键直接相关，而不能间接相关
-- 例如:作为用户表的主键（userID），用户购买的商品与userID是间接的关系，而不是直接关联，
-- 所以不能出现在用户信息表中，应该独立领出来成为一张表




-- BC范式  BCNF
-- 定义：消除每⼀属性对候选键的传递依赖 ,BCNF是修正的第三范式
-- 人话：一个表中不能出现某一属性或多个属性的集合可以和主键相互推出
```



#### 7.2.2 注意事项：

> **一般的项目不需要达到过高的范式，一般达到第三范式完全足够**



### 7.3 公里系统



```

-- 1. 公里本身




-- 2.公里推出的定理
```

![](https://blog-use-1316646528.cos.ap-nanjing.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93/dnUse2.jpg)

### 7.4 最小函数依赖



```sql
-- 7.4.1 依赖的概念：
-- 依赖是指关系中⼀个或⼀组属性的值可以决定其它属性的值⽐如 A->B这就是⼀个依赖



-- 7.4.2 解最小函数依赖
-- 1.拆右边为多个元素的   ⽐如A->BC 拆为  A->B 和A->C 
-- 2. 出去当前元素,求它的闭包,把集合⾥⾯所有元素都弄完
-- 3. 左边最小化(通过遮住元素来看能不能退出其他元素)    比如BCD,遮住B看能退出CD吗 , 遮住C能退出BD吗 遮住D看能退出BC吗


-- 例题在下面：
-- 例题题目： 已知关系 R<U,F> ,U{A,B,C,D,E,F,G}   F={BCD->A,BC->E,A->F,F->G,C->D,A->G}  求F的最小依赖集
```

![](https://blog-use-1316646528.cos.ap-nanjing.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93/dbUse3.jpg)



### 7.5 模式分解



#### 7.5.1  准则与概念

```sql
-- 1 准则: 做到无损连接   和 保持函数依赖 

-- 2 无损: 就是分解后再次连接,和分解之前⼀样
-- 3 依赖:  依赖不变


-- 相关例子：

-- 例1:学生表(学号,姓名) 课程表(课程号,名称) 成绩表(学号,课程号,分数)
-- 进行学生表与成绩表连接,连接条件是学号,这是一个无损连接,也保留了函数依赖。因为学生表中的学号函数决定姓名,在成绩表中也依然如此。


-- 例2:供应商表(供应商号,名称,地址) 零件表(零件号,名称,颜色) 供应表(供应商号,零件号)
-- 进行供应商表与供应表连接,连接条件是供应商号,这也是一个无损连接,且保留函数依赖。因为供应商表中的供应商号函数决定名称和地址,在连接后的结果中也仍然如此。
```

#### 7.5.2  求模式分解



```sql

## 具体步骤：

-- 1.求出本题的最小函数依赖集
-- 2. 把不在F⾥⾯的属性都找出来,单独分⼀类
-- 3.把每⼀个依赖左边相同的分成⼀类,没有⼀样的,那么就把A->D改为{AD}  
-- 4.如果⼀样{A->B,A->C} 那么久改为{ABC}
-- 5.如果候选码没出现在分离⾥⾯, 把任意⼀个候选码作为⼀类




## 例题与解答：

-- 例题：已知R(ABCDEGH)  ,F={A->D,E->D,D->B,BC->D,DC->A} ,求保持函数依赖的3NF

-- 分布解答：

-- 1.最小函数依赖集Fmin={A->D,E->D,D->B,BC->D,DC->A} 
-- 2.GH没在F⾥⾯, 单独⼀类{GH}
-- 3.求出候选码:  CE
-- 4.写出结果：{AD}{ED}{DB}{BCD}{DCA }{CE}{GH}


```



## 第八部分：数据库设计

### 8.1 设计的基本步骤



1. **数据库需求分析:**分析业务需求和数据需求,确定数据库**需要满足的功能和存储的数据**。这个阶段需要与业务人员充分沟通,理解业务流程和数据特点
2. **数据库概念设计:**根据需求分析结果,**识别实体及其属性**,建立**实体关系图,确定主键和外键**,表达数据的概念结构。这一阶段建立一个抽象但准确的模型,为下一步提供蓝图**（全局ER图或者数据字典）**
3. **数据库逻辑设计:**在概念设计的基础上,使用数据模型来表示实体及其关系,如E-R图或类图等。逻辑设计阶段不依赖于具体数据库,只关注数据的逻辑结构。需要处理实体的属性细节和关系参与度问题**（把ER图转为逻辑模型）**
4. **数据库物理设计:**将逻辑设计转化为特定数据库的物理结构,如**表、约束、视图、存储过程等**。需要考虑数据库的**性能、安全、事务、并发控制**等具体要素。物理设计阶段的输出是可以直接在目标数据库中创建的表结构和程序



### 8.2  ER图（重点）

#### 8.2.1 构建

**注意几个点即可：**

- 实体是⻓⽅形体现，
- 属性则是椭圆形
- 关系为菱形

![](https://blog-use-1316646528.cos.ap-nanjing.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93/ERpic1.png)

#### 8.2.2 对应关系

**类型：**

- **1对1（1:1）** ：1对1关系是指对于实体集A与实体集B，A中的每⼀个实体⾄多与B中⼀个实体有反之，在实体集B中的每个实体⾄多与实体集A中⼀个实体有关系
- **1对多（1:N）** ：1对多关系是指实体集A与实体集B中⾄少有N(N>0)个实体有关系；并且实体集B中每⼀个实体⾄多与实体集A中⼀个实体有关系
- **多对多（M:N）** ：多对多关系是指实体集A中的每⼀个实体与实体集B中⾄少有M(M>0)个实体有并且实体集B中的每⼀个实体与实体集A中的⾄少N（N>0）个实体有关系



**例子：**

- **1对1的例子：**一个人对应一个身份证号

- **1对多的例子：**

  ```sql
  -- 部门和员工:一个部门有多名员工,一个员工只属于一个部门
  
  ```

  

- **多对多的例子：**

  ```sql
  -- 学生和课程:一个学生可以选择多门课程,一门课程也可以被多个学生选修
  -- 角色和权限:一个角色可以具有多个权限,一个权限也可以被赋予多个角色
  -- 医生和病人:一个医生可以诊疗多个病人,一个病人也可以找多名医生就诊
  ```

  



## 8.3  ER图转关系模型（重点）

### 8.3.1 简介：

> **就是将ER图中的实体转换成表，属性转换为列，关系转化为中介（但构建时，中介必须合并到实体中）**

### 8.3.2 中介合并问题！！！！！！！！：



- **1:1的关系，** 中介属性随便合并到任意一个表中（假设是中介到A表中 ，那么还要将B表的主键传给A一份）
- **1:n的关系，** 中介属性和1表的主键都要放到N表中去
- **n:m的关系，**两个实体表的主键和需要中介实体的属性单独封装成一个表



**实例图片：**

![](https://blog-use-1316646528.cos.ap-nanjing.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93/ERpic2.webp)

![](https://blog-use-1316646528.cos.ap-nanjing.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93/tmp1.jpg)

**二元类型转化与上面解析：**

```sql
-- 1）如果实体间联系是1:1，可以在两个实体类型转换成的两个关系模式中任意一个关系模式的属性中加入另一个关系模式的键和联系类型的属性。

-- 2）如果实体间联系是1:N，则在N端实体类型转换成的关系模式中加入1端实体类型的键和联系类型的属性。

-- 这两句话听起来是不是有点绕，看下面这个例子（由于上述ER图没有1:1联系，为方便说明，我们假设平台和管理员之间的联系同时存在1:1和1:N）

-- 对于1:1联系“聘用”，可以在“平台”关系模式中加入管理员账号ID（管理员账号ID是外键）；

-- 对于1:N联系“聘用”，则在“管理员”关系模式中加入商标和聘期两个属性（商标是1端的键）:

-- ①平台（商标，名称，所属公司，管理员的账号ID）
-- ②管理员（账号ID，账号密码，用户名，商标、聘期）
-- 3）如果实体间联系是M:N，则将联系类型也转换成关系模式，其属性为两端实体类型的键加上联系类型的属性，而键为两端实体键的组合。

-- 对于M:N联系“下单”和“上传发布”，则生成两个新的关系模式：

-- ①下单（商品编号，顾客账号ID，订单编号，订单数量，下单时间）
-- ②上传发布（商品编号，管理员账号ID，发布时间）
```



三元类型转化

```sql
-- 1）如果实体间联系是1:1:1，可以在三个实体类型转换成的三个关系模式中任意一个关系模式的属性中加入另两个关系模式的键（作为外键）和联系类型的属性。

-- 2）若实体间联系是1:1:N，则在N端实体类型转换成的关系模式中加入两个1端实体类型的键（作为外键）和联系类型的属性。

-- 3）若实体间联系是1:M:N，则将联系类型也转换成关系模式，其属性为M端和N端实体类型的键（作为外键）加上联系类型的属性，而键为M端和N端实体键的组合。

-- 4）若实体间联系是M:N:P，则将联系类型也转换成关系模式，其属性为三端实体类型的键（作为外键）加上联系类型的属性，而键为三端实体键的组合。
```





## 第九部分：嵌入式SQL

> **本部分不同的语言，运用的方案都不一样，实际开发根据技术进行选型就行，期末考试不会考实践，撑死考相关的理论**

 



### 9.1 简介

**就是把SQL语句嵌⼊到 其他编程语⾔⾥⾯  ⽐如java、python**

### 9.2 处理过程  

1. 预编译转换为函数调⽤
2. 主语⾔编译
3. 变成主语⾔所编译的类型

### 9.3 主语言通信

1. SQL给主语⾔传递状态
2. 主语⾔给SQL提供参数
3. SQL把查询结果交给主语⾔处理(游标,和主变量实现)



## 第十部分：查询处理与查询优化



### 10.1 查询的处理流程

1.   查询分析
2. 查询检查
3. 查询优化
4. 查询执⾏

### 10.2 查询的优化方案

**代数优化就是本章讲的重点, 即为：优化树**

1. 选择运算尽量先做
2. 把投影运算和选择运算同时执⾏
3. 把投影同它前后的双⽬运算符连接起来



## 第十一部分：数据库恢复技术

### 11.1 事务的概念及四大特性：

**ACID:**

- **原⼦性 autom** ：要么全做，要么全不做**（做一半出问题了，前面就不能要了）**
- **⼀致性 consistent** ：⼀致性与原⼦性密切相关，要么全做要么全不做，否则就会造成数据不⼀致。⽐如说：银⾏汇钱
- **隔离性isolate** ： ⼀个事务的执⾏不能被其他事务所⼲扰
- **持久性 duration** ：数据库的改变是永久的。⽐如要落⼊磁盘



### 11.2 故障种类：

- **事物内部故障  :**  采取REDO重做和UNDO撤销技术
- **系统故障 DBMS  :**  系统突然停转，系统要重启
- **介质故障  :**  硬件损坏
- **计算机病毒**



### 11.3 恢复方式与备份策略：

#### 11.3.1 恢复方式：

- **数据转储：**对失败的事务重新执⾏
- **⽇志⽂件：**记录事务对数据的更新操作的⽂件



#### 11.3.2 恢复策略：

- **事务故障的恢复：**事务异常终⽌，那么就撤销之前的所有操作
- **系统故障的恢复：**还没执⾏完的事务UNDO、丢失的事务REDO。
- **介质故障的恢复：**重装数据库，重做已经完成的事务



#### 11.3.3 备份策略：

> **理论考试不会考，实际项目中还是不同语言不一样**





## 第十二部分：数据库并发控制

### 12.1  并发的概念：

### 12.2  并发所存在的问题：

- **丢失修改：**我修改的东⻄没⽣效。⽐如说我把票价改成99元，结果还是原来的299元
- **读脏数据：**⽐如，你要读取数据库中的字段A、字段B，你读取时恰巧有其他⽤户正在更新这2个字段，⽽且如果那个⽤户更新⼀半你就读取了，也就是说更新了A，正打算要更新B但尚未更新时，你就读取
- **不可重复读：**我在⼀个事务中，连续两次读到的数据不⼀样。⽐如我刚开始读到银⾏余额为10元。此时单位突然给发⼯资100到这张卡,那么我第⼆次读就变

**例子：**

```sql

-- 1. 丢失修改:
-- 事务1读取数据A,值为1。
-- 事务2也读取数据A,值为1。
-- 事务1将数据A修改为2,并提交。
-- 事务2也将数据A修改为3,并提交。
-- 结果数据A的值为3,事务1的修改被丢失。



-- 2. 脏读:
-- 事务1读取数据A,值为1。
-- 事务2修改数据A为2,但未提交。
-- 事务1又读取数据A,值为2。
-- 事务2回滚,数据A回到1。
-- 事务1读取的值（1）是脏数据,不准确。




-- 3. 不可重复读:
-- 事务1读取数据A,值为1。
-- 事务2修改数据A为2,并提交。
-- 事务1再次读取数据A,值为2。
-- 事务1两次读取的数据不同,产生不可重复读问题。
```



### 12.3  了解并发锁：

- **排它锁：**也叫写锁  X锁    允许事务读取数据,但不允许修改数据。共享锁可以被多个事务同时持有,以实现并发读取
- **共享锁：**也叫读锁  S锁    允许事务修改数据,但不允许其他事务访问数据。排他锁只能被一个事务独占,实现数据修改的互斥



### 12.4  解决办法与三级锁协议：

```sql
-- 1.⼀级封锁协议
-- 修改时，必须加X锁，直到结束

-- 2.⼆级封锁协议
-- 读的时候，加S锁，⽤完就放

--  3、三级封锁协议
-- 读的时候，加S锁，直到结束





-- ⼀级锁协议：解决丢失修改
-- ⼆级锁协议：解决读脏数据
-- 三级锁协议：解决不可重复读
```

![](https://blog-use-1316646528.cos.ap-nanjing.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%B9%B6%E5%8F%91.jpg)

### 12.5  可串行性：

```sql

-- 假设多种情况都可以,然后获得结果,
-- 如果并发执⾏的结果跟上⾯的结果⾥⾯任意⼀个⼀样就可以

-- 事务T1: 读取B,A=B+1,写回A
-- 事务T2: 读取A,B=A+1,写回B

-- 假设先T1, 再T2 , 那么A=4,B =3;
-- 假设先T2 ,再T1那么A=3, B =4;


-- 只要数据库执行结果满足其中之一，即满足可串行性

```





## 额外第一部分：可能题目类型：

### x_1.1  选择题：

### x_1.2  填空题：

### x_1.3  大题目：



