# 前端八股文刷题第一天

> **声明注意：本问所有题目答案均有 GPT4 和 Claude 生成，大部分题目个人都过了一遍，但仍不保证都完全正确！！！**

## H5基础部分：

### 第一题：

> **1.1 ---HTML中的Iframe与HTML5的Canvas有什么区别?各自的作用是什么?**



- Iframe是HTML内嵌框架,用于在页面中嵌入其他网页。Canvas是HTML5新增的用于在网页实时生成图像(图形)的元素。
- Iframe需要加载完整的页面内容,包括HTML、CSS、JS等。Canvas只需要JavaScript代码来绘制图形,性能更高。
- Iframe独立于主页面,有自己的DOM和JavaScript环境。Canvas由主页面的JavaScript控制,没有自己的DOM。
-  Iframe可通过src属性指向页面地址进行加载。Canvas需要通过JavaScript代码绘制内容。
- Iframe用于富媒体页面的组合,Canvas用于图像的动态绘制与处理。虽然Canvas显得更“前端”和更具互动性,但Iframe也依然有着广泛的使用场景



### 第二题：

> **1.2 ---HTML5中新增的语义化元素有哪些?作用分别是什么?**

- header 标记文档或页面的头部区域
- nav 标记导航链接的部分
- aside - 标记非内容本身的内容(如广告、作者简介等)
- section -  标记文档中的节(section、区段)
- article - 标记独立的文章内容
- footer - 标记文档或页面的尾部区域 
- main - 标记文档的主要内容 
- mark - 标记需要突出显示的文本
- details- 标记用户可以查看或隐藏的额外细节
- summary - <details> 元素的标题



**总体作用：**

- 加强程序与网页语义化,便于其他设备解析(如屏幕阅读器)
- **便于SEO优化,**搜索引擎可以更好理解网页结构和内容
- 便于维护,代码结构更加清晰





## C3基础部分：

### 第一题：

> **2.1- - CSS3的Flexbox布局和Grid布局有什么区别?各自的优点是什么?** 

**Flexbox布局:**

- 用于一维布局,可以在页面上排列项目和项目间的分割空间

-  轴性布局,通过flex-direction、flex-wrap、flex-flow和order等属性控制项目位置
- 项目大小可变,可以通过flex-grow和flex-shrink属性进行宽度分配
- 适用于变化的布局,可以使容器内的项目灵活变换大小
- 相关核心属性：flex-direction  flex-wrap  flex-flow  justify-content  align-items   align-content  order

**Grid布局:**

- 用于二维布局,可以在行和列上对齐和分布项目

- 通过grid-template-rows, grid-template-columns确定行和列轨道大小

- 可以指定项目放置在哪个区域,通过grid-row和grid-column进行项目定位
- 固定跨度的布局,指定宽度/高度值后项目大小不会随容器变化而变化
- 可以指定项目间距,控制宽度/高度比例等

**Flexbox布局:**

- 简单和轻量级,容易上手和实现常见的布局

- 良好的浏览器支持,适用于移动端布局

- 灵活性高,适应屏幕大小变化

  

**Grid布局:**

- 强大的布局能力,可以实现几乎所有的二维布局
- 可以轻松实现复杂的页面布局,特别适合后台产品布局
- 支持任意的跨度组合,创建具有高度可变性的布局





### 第二题：

>  **2.2 --Less是什么?与CSS有什么关系?Less的主要功能和优点是什么?**



**关系：**

- Less 需要先编译为 CSS,然后浏览器才能识别和理解。
- Less 扩展了 CSS 的语法和功能,提供更强大的语言特性,但最终仍是被编译成标准的 CSS 代码。
- 所以可以说 Less 是 CSS 的超集,任何标准的 CSS 代码也是正确的 Less 代码。



**优点和主要拓展点：**

-  **变量**:可以在 Less 文件中定义变量,并在文件内多处调用和使用,提高代码的可维护性。
- **混合(Mixin)**:可以将样式从一个规则集引入到另一个规则集,起到代码复用的效果。
- **嵌套**:可以在一个选择器中嵌套另一个选择器来实现继承,体现了层级关系。
- **函数**:Less 内置了多种函数用于转换颜色、处理字符串、算术运算等。
- **运算**:支持加、减、乘、除运算,可以在代码中进行算术运算。
- **注释**:支持块注释和行注释,方便代码的阅读和理解。
- **导入**:可以导入外部的 Less 文件,实现文件的复用和项目的模块划分。





### 第三题：

> **2.3 --浮动和定位的区别是什么?清除浮动的方法有哪些?** 

**浮动：**

- 浮动的元素会脱离文档流,周围的元素会忽略它的存在而填补它的空间。
- 浮动的框可以向左或向右移动,直到它的外边缘碰到包含框或另一个浮动框的边框。
- 用于实现文字环绕效果,制作布局等。
- 

**定位：**

- 定位会改变元素的布局行为,使其脱离正常的文档流。
- 使用position和top、bottom、left、right等属性对元素进行定位。
- 用于精确控制元素的位置和布局等。

**清除浮动的方法：**

-  使用空的div清除浮动:在浮动元素后增加一个空的div,并设置clear:both。

- 使用overflow:（为父元素设置overflow: auto或overflow: hidden。）

- 使用伪元素清除浮动:

  ```css
  .clearfix::after {
    content: "";
    clear: both;
    display: block;
  }
  ```

  

- 使用BFC清除浮动:

  为父元素设置float、position(absolute、fixed)、overflow(hidden、auto、scroll)、display(table-cell、table-caption、inline-block)等来触发BFC。

  

  **总结：**

  

  1. 浮动主要影响的是元素本身和其周围的元素,不会影响其子元素和父元素
  2. 定位会完全改变元素的布局特性,并影响到其子元素和父元素。
  3. 清除浮动的目的是消除浮动元素对周围元素产生的影响,一般在浮动元素的父元素上设置。

- 

### 第四题：

> **2.4 --BFC的概念和形成条件是什么?BFC的作用和应用有哪些?**





### 第五题：

> **2.5 --CSS性能优化的方法有哪些?实例和原理分别是什么?**



**主要方法：**

1. 减少HTTP请求数:
   - 结合雪碧图技术,将多张小图片组合成一张大图,减少HTTP请求。
   - CSS文件合并,将多个CSS文件合并成一张CSS文件,减少HTTP请求
   - CSS代码压缩,压缩CSS可以减小文件体积,加快加载速度。
2. 避免CSS表达式和通用选择器:
   - CSS表达式会增加浏览器的计算量,影响性能。应当避免过于复杂的CSS表达式。
   - 通用选择器选取的元素越多,浏览器计算量越大,应当尽量使用类选择器和ID选择器。
3. 充分利用缓存:
   - 为CSS文件设置适当的缓存时间,让浏览器重复访问时直接从缓存中读取,避免重复下载。
   - 使用内容摘要(Content Hash)的方式命名,当内容有变化时才会请求最新的CSS文件。
4. 避免@import:
   - @import会产生额外的HTTP请求,应当避免使用,直接将CSS规则写在一个文件中。
   - 尽量将@import放在样式规则的最前面,这样可以先下载@import引入的文件,减少页面渲染等待时间。



**具体代码实现：**

```css
css
/* 避免CSS表达式 */
.box {
  width: 200px + 100px;  /* 避免这样的CSS表达式 */
  width: 300px;         /* 应该直接写死值 */ 
}

/* 充分利用缓存 */
<link rel="stylesheet" href="styles.20190415.css">  
/* 使用内容摘要命名,内容变化时才会更新缓存 */

/* 避免@import */
@import url("module1.css");    
@import url("module2.css");  

/* 应该直接写在一个CSS文件中 */  
/* module1.css */
/* module2.css */ 

```



**主要原理在于：**

1. 减少浏览器的计算量和处理工作,例如避免复杂的CSS表达式等。
2.  减少网络传输的数据量,例如图片雪碧图、CSS压缩等。
3. 利用浏览器的缓存机制,避免重复下载,减少请求数。
4. 避免阻塞页面渲染,通过将@import放在首位或者直接编写在一个CSS文件中。







### 第六题：

> **2.6 --z-index:0和z-index:auto的区别**

**z-index: 0:**

- 表示堆叠层级最低,会被所有具有高堆叠层级的元素覆盖。
- 如果某个元素没有设置 z-index 或 z-index 为 0,则它的堆叠层级默认为 0。

**z-index: auto:**

- 表示由浏览器自动计算出一个堆叠层级。
- 浏览器会根据元素的父元素和位置来计算出一个合适的堆叠层级。
- 如果父元素也设置为 z-index: auto,则继续回溯到更高级的父元素计算堆叠层级,直到找到一个非 auto 的值。

**所以区别在于:** 

- z-index: 0 表示固定的最低堆叠层级,层级不会发生变化。
- z-index: auto 表示堆叠层级由浏览器根据元素位置和父元素层级自动计算,层级可能会发生变化。



**例如（有例子代码如下）：**

```html
<div class="parent">
  <div class="child1">z-index: 0</div>
  <div class="child2">z-index: auto</div>
</div>
```

如果 parent 的 z-index 设置为 10,则:

**child1 的层级为 0**,会被 parent 遮挡。
**child2 的层级会被浏览器计算为 11**(parent 层级 10 + 1),所以会显示在 parent 之上。



# 前端八股文刷题第二天

## 计算机网路原理部分：

### 第一题：

> **3.1 --三次握手和四次挥手的目的及过程分别是什么?**



### 第二题：

> **3.2 --GET和POST的区别是什么?各自的应用场景是什么?**



### 第三题：

> **3.3 --HTTPS和HTTP的区别是什么?HTTPS的工作原理是什么?**   

### 第四题：

> **3.4 --DNS服务器的作用是什么?DNS解析的过程是怎样的?** 

1. 浏览器将输入的域名发送给操作系统,操作系统检查是否有本地DNS缓存,如果有直接返回IP地址给浏览器。

2. 如果没有本地缓存,操作系统会查询本地DNS解析器(localhost),本地解析器首先检查HOSTS文件是否有对应记录,如果有直接返回IP地址。

3. 如果HOSTS文件没有对应记录,本地解析器将域名解析请求发送给ISP指定的DNS服务器。

4. ISP的DNS服务器检查是否有对应的记录,如果没有会继续向域名注册商的DNS服务器发出递归查询。

5. 域名注册商DNS服务器获取到对应IP地址后,将信息返回给ISP的DNS服务器。ISP的DNS服务器将信息存入本地,并返回给本地解

6. 本地解析器将IP信息返回给操作系统,操作系统返回给浏览器。浏览器可以使用该IP地址访问网站。

7. 浏览器将域名和IP地址存入本地DNS缓存,一定时间内(根据DNS服务器TTL值)会直接从缓存中读取IP地址,避免重复查询

   

### 第五题：

> **3.5 --浏览器页面渲染过程**

1. 解析 HTML 构建 DOM(DOM 树)，并行请求 css/image/js
2. CSS 文件下载完成，开始构建 CSSOM(CSS 树)
3. CSSOM 构建结束后，和 DOM 一起生成 Render Tree(渲染树)
4. 布局(Layout)：计算出每个节点在屏幕中的位置
5. 显示(Painting)：通过显卡把页面画到屏幕上

### 第六题：

> **3.6 --网页缓存的方法有哪些?作用和应用场景分别是什么?**



### 第七题：

> **3.7 --从浏览器地址输入url到显示页面的步骤**

1. 浏览器根据请求的 url 交给 dns 域名解析,找到真实的 ip, 向服务器发送请求;
2. 服务器交给后台处理完成后返回数据,浏览器接收文件( html, js, css,图像等);
3. 浏览器对加载到的资源( HTML, JS, CSS等)进行语法解析,建立对应的内部数据结构(如 HTML 的DOM );
4. 载入解析到的资源文件,渲染页面,完成

### 第八题：

> **3.8 --http 2.0和http 1.1区别？，并主要解决了什么问题？**

**主要区别：**

- **二进制分帧**:HTTP/2 使用二进制分帧代替文本报文,提供更强的扩展能力。
-  **头部压缩**:HTTP/2 允许同时发送多个请求和响应,并压缩请求和响应的头部,提高传输效率。
- **多工**:HTTP/2 支持通过一个连接并行传输和接收多个消息,而HTTP/1.1需要多个连接。
- **服务端推送**:HTTP/2 允许服务端主动向客户端推送资源,而不需要客户端进行请求。
- **重要性优先**:HTTP/2 支持重要性高的消息优先处理,主要用于提高页面加载性能。 

**主要解决了的问题：**

- **通信效率低**:HTTP/1.1 每个请求/响应都需要建立新的连接,效率较低。HTTP/2 使用单个连接,实现并行传输,提高效率。
- **滥用TCP连接**:HTTP/1.1 中,浏览器会建立多个连接来实现并行下载多个资源,这会过度占用TCP连接,影响应用层的性能。HTTP/2 使用单连接并行传输,避免这一问题。
- **头部大小**:HTTP 请求和响应的头部会占用较大流量,HTTP/2 对头部进行压缩,减小网络流量。
- **页面加载慢**:HTTP/1.1 需要按序下载页面资源,页面加载时间长。HTTP/2 支持重要性优先,可以优先下载对页面渲染更重要的资源,加快页面加载。
- **服务端推送**:HTTP/1.1 无法实现服务端主动推送资源,HTTP/2 支持服务端推送,提高用户体验。





### 第九题：

> **3.8 -强缓存与协商缓存**

**协商缓存：**

1. 协商缓存需要在每次请求时,浏览器发送一个304状态的请求给服务器,询问资源是否有更新。
   - 如果资源未更新,服务器返回304告知浏览器直接使用缓存。
   - 如果资源更新了,服务器返回200和新的资源,浏览器就会更新缓存。
2. 常用的协商缓存策略有:
   - Last-Modified:传入资源的最后修改时间,与服务器的最后修改时间比较
   - ETag:传入一个资源标识符,与服务器上的ETag比较 
3. 协商缓存可以在资源更新时很快生效,但是会增加一定网络开销。



**强缓存：**

1. 强缓存的数据有一个固定的过期时间,在这个时间段内浏览器会直接从缓存中读取数据而不会发送任何网络请求。
2. 常见的强缓存策略有:
   - Expires:设置一个固定的过期时间
   - Cache-Control:max-age:也设置一个过期时间
3. 强缓存可以大大提高网站性能,但是如果文件更新了也无法立即生效,需要等缓存过期。









# 前端八股文刷题第三天

## JS基础部分：

### 第一题：

> **4.1 --讲一讲JS时间循环机制**

**基本要点：**

- 同步代码，调用栈执行后直接出栈
- 异步代码，放到Web API中，等待时机，等合适的时候放入回调队列（callbackQueue），等到调用栈空时eventLoop开始工作，轮询
- 微任务执行时机比宏任务要早
- 微任务在DOM渲染前触发，宏任务在DOM渲染后触发
- 
- 微任务是由ES6语法规定的
- 宏任务是由浏览器规定的

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbd9cfac79eb4e0896b82f2ae4074d6a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b56216304f0948ae82a1599c868f1f90~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)







### **第二题：**

> **4.2 --JS手写深拷贝**



**基础简易板（未考虑边界情况）：**

```javascript
function isObject(target) {
    const type = typeof target;
    return target != null && (type === 'object' || type === 'function')
}


function clonedeep(target,map=new WeakMap() {
    //处理基本数据类型
    if (!isObject(target)) {
        return target
    }
    //处理对象
    if (typeof target === 'object') {
+       let result = Array.isArray(target)?[]:{}
        if (map.get(target)) {
            return map.get(target)
        }
        map.set(target, result)
        for (const key in target) {
            result[key] = clonedeep(target[key],map);
        }
        return result;
    }
}

```

**复杂版本（较为全面覆盖）**

### 第三题：

> **4.3 --js中的map与wakMap的关系与对比**

**题外话（map的特点）：**

- 键名不限于字符串,各种类型的值都可以作为键名或键值。

- 具有更好的迭代方面,Map 直接支持 for..of 等遍历语法。

- 元素有序,插入顺序与读取顺序一致。

- size 属性可以快速获取键值对数量。

- 可以直接迭代values、keys 和 entries。

  

**WeakMap的特点：**

- 键名只能是对象类型,键值可以是任意类型。
- 键值对是无序的。
- 键值对个数无法获取。
- 不能被迭代,不支持遍历。
- 如果键名对象被GC,对应的键值对会自动消失。

**总结：**

1. WeakMap 的键名只限于对象类型,而 Map 的键名和键值都不限制类型。

2. WeakMap 键值对是弱引用,键名对象被 GC 时键值对会消失。Map 中的键值对是强引用,不会因键名GC而消失。

3. WeakMap 不可被遍历和获取元素个数,而 Map 支持遍历和获取 size。

   

**应用场景：**

1. 
2. 







### 第四题：

> **4.4 --react父组件和子组件的useEffect哪个先执行**

1. 父constructor
2. 父componentWillMount
3. 父render
4. 子constructor
5. 子componentWillMount
6. 子render
7. 子componentDidMount
8. 父componentDidMount



**虽然useEffect**可以简单看作是componentDidMount、componentDidUpdate和componentWillUnmount的组合

**但是react保证了每次运行effect的同时，DOM都已经更新完毕**

故而，在react函数式组件写法的父子组件中，**useEffect的执行顺序是：**

1. **子effect**
2. **父effect**





### 第五题：

> **4.5 --箭头函数与普通函数区别**

- **语法更加简洁、清晰**
- **箭头函数没有 prototype (原型)，所以箭头函数本身没有this**（但会捕获上下文的this用开始用，所以直接书写的箭头函数，捕获的是window对象）
- **call | apply | bind 无法改变箭头函数中this的指向**
- **箭头函数不能作为构造函数使用**
- **箭头函数不绑定arguments，取而代之用rest参数...代替arguments对象，来访问箭头函数的参数列表**
- **箭头函数不能用作Generator函数，不能使用yield关键字**









# 前端八股文刷题第四天：

## git管理部分：

### 第一题：

> **5.1 --在团队合作是git可能出现的问题及原因和解决办法**

1. 冲突(conflict)

   - 原因:多人对同一文件进行了修改,并尝试合并时产生冲突。
   - 解决:手动解决冲突,根据实际情况保留所需修改,删除标记后提交。

2.  提交覆盖(overwrite)

   - 原因:多人在同一分支上提交,后提交的覆盖先提交的部分修改。
   - 解决:使用 Git 提交之前进行 Git pull,发现有冲突则解决冲突后提交。或使用分支策略,多个人在不同分支开发,合并时解决冲突。

3. 远程分支落后(out of date)

   原因:多人开发,某个开发者的本地分支与远程分支不一致,提交至远程时报此错误。

    解决:先通过 Git fetch 或 pull 将本地分支更新到远程分支的最新提交,然后再 push。

4. 分支合并时的冲突(merge conflict)

   - 原因:不同分支上的开发者,对同一文件的同一部分进行了不同的修改,在 attempted merge 时产生冲突。
   -  解决:手动解决冲突,保留所需修改,删除标记后提交。最好在 merge 前 pull,解决可能存在的其他冲突。

5. 推送被拒(push rejected)

   - 原因:此问题多因本地分支不是最新的所致,解决办法同“远程分支落后”。也可能是没有权限向远程分支推送。 
   - 解决:更新本地分支,确保其为最新。检查是否有推送权限,若无需申请权限。

6. 没有提交权限(no commit access) 

   - 原因:尝试向受保护分支(通常为 master)直接推送或合并,但没有该分支的提交权限。

   -  解决:不直接向 master 分支推送,可以采用 Pull Request 申请合并,由有权限的管理员审核后合并,或申请推送权限。

     



### 第二题：

> **5.2 --在团队合作是git可能出现的问题及原因和解决办法**

1. 冲突(conflict)







